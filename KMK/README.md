# 1. 로깅의 중요성
- 시스템 개발과 운영에서 **Logging**은 단순한 출력이 아니다. 
- 시스템의 가시성을 높혀준다.
- 운영 / 보안 / 장애 분석에서 매우 중요한 역할을 한다.
- Logging은 운영팀 / 개발팀 / 보안팀에게 매우 핵심적인 요소이다. 
## 운영
- 시스템의 상태 추적을 통해 현재 시스템이 어떠한 상태인지 파악할 수 있다.
- 사용자가 시스템을 이용하면서 사용자 흐름, 주로 사용하는 기능들을 파악해 향후 개선 방향을 도출할 수 있다.
- 응답 시간(Latency), 트래픽, CPU/메모리 사용률 등 성능 지표 모니터링에도 활용되며,
  이는 성능 개선이나 리소스 최적화의 근거가 된다.

## 보안
- 어떤 사용자가 어떠한 경로로 접근했는지 파악할 수 있다.
- 비정상적인 호출을 탐지할 수 있다. 예를 들어, 비정상적인 로그가 3분동안 10회이상 발생하면 이슈가 있다고 판단할 수 있다.

## 장애
- 시스템 오류율을 0%에 가깝게 달성하기 위해서는 우선 에러를 추적해야 한다.
- 이를 예외 메세지 혹은 스택 트레이스같은 것으로 파악할 수 있다.

# 2. 중앙집중 로그 시스템
- 우선 왜 중앙 집중 로그 시스템이 필요한지 알아야한다.
- 예를 들어, 단일 서버에서 백엔드 서버의 로그를 남긴다고 가정하자.
- tail -f app.log와 같은 명령어로 간단하게 확인할 수 있다.
- 하지만 시스템이 점차 커지고, 서비스가 분산되어 서버가 많아지면 다수의 서버를 tail 명령어로 확인하는 것은 당연히 비효율적이다.
  즉, 운영 리스크를 키울 수 있다.
- 따라서 모든 서버의 로그를 한 곳으로 모아 수집/저장/분석할 수 있는
  중앙집중 로그 시스템이 필요하다.

## 목적
- 로그 통합 수집: 수백/수천 개 서버의 로그를 한 곳에서 실시간으로 수집
- 장애 발생 시 빠른 탐지 및 추적: 서비스 전체에서의 오류 패턴, 시간 순서, 관련 서비스 추적
- 검색 및 필터링: 로그 키워드 검색, 필드별 필터, 시간 조건 등으로 빠르게 진단
- 시각화 및 모니터링: 대시보드, 차트, 경고(Alert) 등으로 운영 효율성 향상
- 보안 및 감사 용도: 모든 로그를 장기 저장하여 추후 침해 조사, 행위 분석 가능

## 구축 사례
- 보통 ELK 혹은 EFK로 많이 구축한다.
- 이유는 다음과 같다.

1. 검색 및 분석 기능이 강력하다 (Elasticsearch)
- Elasticsearch는 로그 데이터를 색인(index) 처리하여 대용량 로그에서도 빠른 검색이 가능함
- 복잡한 쿼리, 필터링, 정렬, 범위 조건 등을 실시간으로 수행할 수 있어 운영 및 장애 분석에 매우 효율적


2. 시각화 및 대시보드 제공 (Kibana)
- Kibana는 로그를 시각화하여 대시보드 형태로 직관적으로 표현해줌
- 시간별 트래픽, 에러 발생률, 사용자 활동 등을 그래프, 차트, 테이블로 시각화
- 비기술자도 로그 데이터를 이해하고 활용할 수 있게 도와줌


3. 유연한 로그 수집 및 전처리 (Logstash/Fluentd)
- 다양한 입력(Input) 소스와 출력(Output) 대상 지원
- 예로 파일, Kafka, Syslog, DB → Elasticsearch, S3 등 Logstash와 Fluentd는 각각 강력한 플러그인 기반 아키텍처로
   상황에 따라 로그 필터링, 정제, 변환이 가능함
```
[백엔드 서버] 
  ↓ 로그 발생
[Fluentd]  
  ↓ 로그 수집 및 전달
[Elasticsearch]  
  ↓ 로그 저장 및 검색 가능하게 인덱싱
[Kibana]  
  → 시각화 대시보드 제공
```
4. 대규모 운영 경험과 커뮤니티 축적
- ELK/EFK는 대기업부터 스타트업까지 폭넓게 사용되고 있으며
  관련 문서, 사례, 에러 해결 자료가 풍부함

# 3. Fluentd vs Logstash
- 공통적으로 입력(Input) → 필터(Filter) → 출력(Output) 구조를 가지고 있지만,
  성능, 리소스, 사용 환경 등에서 차이가 있다.

| 항목             | Fluentd                          | Logstash                             |
|------------------|-----------------------------------|---------------------------------------|
| **개발 언어**     | C / Ruby                         | JRuby (JVM 기반)                      |
| **리소스 사용량** | 낮음 (경량)                      | 높음 (JVM으로 인해 메모리 사용 큼)     |
| **성능**         | 높은 처리량, 실시간 스트리밍 최적화    | 보통, 대용량 처리 시 튜닝 필요          |
| **플러그인 수**   | 500개 이상                        | 200개 이상                            |
| **구성 편의성**   | 설정이 단순 (`td-agent`, YAML 기반) | 유연하나 복잡 (pipeline DSL 사용)      |
| **Kubernetes 연동** | 매우 적합 (Fluent Bit와 함께 사용됨) | 잘 사용되지 않음                      |
| **디버깅/가시성** | 로그 기반 디버깅 쉬움                | Kibana UI와 연동해 디버깅 가능          |
| **실시간 처리**   | 스트리밍 최적화                    | 약간의 버퍼 지연 있음                   |
| **사용 사례**     | EFK Stack, Kubernetes, 클라우드 환경 | ELK Stack, 온프레미스, 복잡한 전처리    |

- Fluentd가 리소스 측면에서 가볍고 Kubernetes 환경에서 유리하다는 장점은 분명하지만,
  Logstash는 여전히 Grok 필터 기반의 정교한 로그 파싱이 필요할 때 선택되는 유력한 대안이다.
  특히 Elastic사에서 직접 개발한 통합 스택인 ELK는 성숙도와 안정성 면에서 높은 신뢰를 받고 있으며,
  많은 기업이 기존 ELK 기반의 관제 시스템이나 모니터링 구조를 유지하고 있다.

# 결론
결론적으로, EFK는 CNCF에서도 클라우드 네이티브 환경에서의 로그 수집 표준 스택으로 강력하게 권장되고 있다.

특히 대부분의 시스템이 Kubernetes 기반으로 운영되고 있는 만큼,
Fluentd는 다음과 같은 이유로 사실상 로그 수집의 표준 구성 요소로 자리잡았다.
- DaemonSet 배포 구조를 통해 모든 노드의 로그를 자동 수집할 수 있고
- 리소스 소모가 적어 컨테이너 환경에 최적화되어 있으며
- Prometheus, Grafana, Loki 등 다른 클라우드 네이티브 도구들과도 유연하게 연동됩니다.

따라서, 어차피 Kubernetes 기반으로 시스템을 운영할 것이라면, Fluentd 기반의 EFK 스택을 선택하는 것이 가장 자연스럽고 효율적인 방향인 것 같다.